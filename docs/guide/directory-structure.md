# 项目结构

一个良好、一致的项目结构是软件工程的最佳实践之一。Maltose 通过 `maltose new` 命令为用户提供了一套经过精心设计的、推荐的项目结构，旨在实现关注点分离，提高项目的可维护性和可扩展性。

当您执行 `maltose new <project-name>` 后，会得到如下的目录结构：

```
.
├── api
│   └── v1
│       └── hello.go
├── cmd
│   ├── server.go
│   ├── config.go
│   └── route.go
├── config
│   └── config.yaml
├── internal
│   ├── controller
│   │   └── hello
│   ├── dao
│   ├── logic
│   │   └── hello
│   ├── model
│   │   ├── entity
│   │   └── do
│   ├── provider
│   └── service
│       └── hello.go
├── utility
├── go.mod
└── main.go
```

以下是各主要目录和文件的职责说明：

### `/api`

存放 API 的定义文件（`.go` 格式）。这里的"定义"主要指请求和响应的 `struct`。Maltose 的代码生成工具会扫描此目录，以生成 Controller 和 Service 层的代码。

- **层级结构**: 推荐使用 `api/{模块}/{版本}` 的方式来组织，例如 `api/user/v1/user.go`。

### `/cmd`

项目的启动入口。负责应用的启动、依赖注入、路由注册等核心初始化工作。

### `/config`

存放应用的配置文件，例如 `config.yaml`。Maltose 的配置组件会默认从此目录加载配置。

### `/internal`

存放项目内部的业务逻辑代码，这是项目的主要工作区。Go 语言的机制确保了 `internal` 包下的代码只能被项目内部引用，无法被外部项目导入。

- **/controller**: 控制器层。负责接收和解析来自路由的请求，进行参数校验，然后调用 `Logic` 层处理业务，最后向客户端返回响应。
- **/dao**: 数据访问对象 (DAO) 层。封装了对数据库的底层操作，直接与数据库交互。此目录下的代码通常由 `maltose gen dao` 生成。
- **/logic**: 业务逻辑层。这是实现具体业务功能的核心，它会组织和编排 `Service` 层提供的能力来完成一个完整的业务流程。
- **/model**: 数据模型层。存放项目所有的数据结构定义。
  - **/entity**: **数据实体 (Entity)**。存放与数据库表结构一一对应的 `struct`。这部分代码由工具（如 `maltose gen model`）自动生成，**不应手动修改**。它是数据持久化的最底层结构。
  - **/do**: **数据对象 (Data Object)**。用于 `DAO` 层与 `Service/Logic` 层之间的数据传输。`do` 的结构通常与 `entity` 相似，但它为业务逻辑与底层数据实现了解耦。在复杂场景下，例如需要联表查询返回自定义结构时，`DO` 是最佳的载体。
  - **业务输入/输出模型 (Input/Output)**：直接定义在 `model` 根目录下的 `struct`，例如 `user_input.go`。用于 `Controller` 与 `Service/Logic` 之间的数据交互，作为内部业务调用的参数和返回值。
- **/service**: 服务接口层。定义了业务逻辑所需的接口（Interface）。`Logic` 层依赖于这些接口，而不是具体的实现，以此实现解耦和依赖倒置。
- **/provider**: 第三方服务封装层。当您的业务需要调用外部 API（例如，其他微服务、SaaS 服务如短信邮件等）时，建议在此目录下进行封装。
  - **职责**: `provider` 的核心职责是"消除外部细节"。它将与第三方服务通信的所有细节（如 HTTP 请求、认证、参数构造、响应解析）都封装起来，仅对内暴露一个清晰、业务化的方法。
  - **最佳实践**: `provider` 内部应优先使用 `maltose` 框架自带的 `mclient` 来发起网络请求。`Logic` 层通过依赖注入直接调用具体的 `provider` 服务，无需定义额外的 `interface`，以保持轻量和高效。
  - **示例结构**:
    ```
    /internal/provider
    └── usercenter/          // 微服务名或第三方服务名，小写
        ├── usercenter.go    // 服务入口，定义 Client 结构体及 New 方法
        └── user.go          // 按业务/资源组织，实现具体的接口调用方法
    ```

#### 关于 `do` 和 `entity` 的思考

为了保持框架的轻量级和灵活性，`maltose` 在数据模型层提供了 `entity` 和 `do` 两种结构，但它们的定位与传统重型框架有所不同。

- **`entity` (实体) - 基础数据模型**

  - **职责**: `entity` 的结构与数据库表结构 **严格 1:1 对应**。`maltose gen model` 命令会为您自动生成并维护它。
  - **定位**: 它是所有标准、简单 CRUD 场景下的 **默认且推荐** 的数据模型。`gen dao` 命令生成的默认方法也直接使用 `entity`。

- **`do` (数据对象) - 可选的高级扩展**
  - **职责**: `do` 目录默认不被强制使用，它是一个**可选的、需要您手动创建**的目录，用于解决 `entity` 无法优雅处理的复杂场景。
  - **定位**: 它不是一个被强制推行的规范，而是一个解决特定问题的"工具箱"。如果您的项目业务逻辑简单，**完全可以忽略或删除 `do` 目录**。

**什么时候应该手动创建和使用 `do`？**

当您的业务发展到一定复杂度，遇到以下场景时，`do` 层将是您的得力助手：

1.  **承载复杂数据库查询结果**: 当您需要执行多表 `JOIN` 或其他复杂 SQL 查询时，其返回结果的结构往往与任何单一的 `entity` 都不匹配。此时，在 `internal/model/do/` 目录下手动创建一个 `struct` 来定义这个专用的结果集，是最佳实践。

2.  **聚合内部业务数据**: 当 `Service` 层需要将来自不同数据源（例如，MySQL 中的 `entity`、Redis 缓存、第三方 API 返回的数据）的信息组合成一个统一的对象，以便在业务逻辑内部流转时，`do` 提供了一个理想的"聚合模型"存放地。

简而言之，`maltose` 的设计哲学是：**`entity` 为本，`do` 为用**。我们默认提供最轻量、最直接的 `entity` 方案满足 80% 的常规需求，同时保留了 `do` 这一扩展能力，让开发者在面对 20% 的复杂问题时，有路可循，有章法可依。

### `/utility`

存放项目范围内的通用工具函数或模块，例如统一的日志记录器、错误码定义等。

通过遵循这套项目结构，您可以更轻松地管理代码，并与团队成员高效协作。
